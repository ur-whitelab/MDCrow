import os
import re
import subprocess
import typing
from typing import Any, Dict, List, Optional, Type, Union

from langchain.tools import BaseTool
from pdbfixer import PDBFixer
from pydantic import BaseModel, Field, ValidationError, root_validator

from mdagent.utils import PathRegistry

from .elements import list_of_elements
from .pdb_tools import MolPDB, validate_pdb_format

##########################PACKMOL###############################


def summarize_errors(errors):
    error_summary = {}

    # Regular expression pattern to capture the error type and line number
    pattern = r"\[!\] Offending field \((.+?)\) at line (\d+)"

    for error in errors:
        match = re.search(pattern, error)
        if match:
            error_type, line_number = match.groups()
            # If this error type hasn't been seen before,
            # initialize it in the dictionary
            if error_type not in error_summary:
                error_summary[error_type] = {"lines": []}
            error_summary[error_type]["lines"].append(line_number)

    # Format the summarized errors for display
    summarized_strings = []
    for error_type, data in error_summary.items():
        line_count = len(data["lines"])
        if line_count > 3:
            summarized_strings.append(f"{error_type}: total {line_count} lines")
        else:
            summarized_strings.append(f"{error_type}: lines: {','.join(data['lines'])}")

    return summarized_strings


class Molecule:
    def __init__(self, filename, file_id, number_of_molecules=1, instructions=None):
        self.filename = filename
        self.id = file_id
        self.number_of_molecules = number_of_molecules
        self.instructions = instructions if instructions else []
        self.load()

    def load(self):
        # load the molecule data (optional)
        pass

    def get_number_of_atoms(self):
        # return the number of atoms in this molecule
        pass


class PackmolBox:
    def __init__(
        self,
        path_registry,
        file_number=1,
        file_description="PDB file for simulation with: \n",
    ):
        self.path_registry = path_registry
        self.molecules = []
        self.file_number = 1
        self.file_description = file_description
        self.final_name = None

    def add_molecule(self, molecule: Molecule) -> None:
        self.molecules.append(molecule)
        self.file_description += f"""{molecule.number_of_molecules} of
        {molecule.filename} as {molecule.instructions} \n"""
        return None

    def generate_input_header(self) -> None:
        # Generate the header of the input file in .inp format
        orig_pdbs_ids = [
            f"{molecule.number_of_molecules}_{molecule.id}"
            for molecule in self.molecules
        ]

        _final_name = f'{"_and_".join(orig_pdbs_ids)}'

        self.file_description = (
            "Packed Structures of the following molecules:\n"
            + "\n".join(
                [
                    f"Molecule ID: {molecule.id}, "
                    f"Number of Molecules: {molecule.number_of_molecules}"
                    for molecule in self.molecules
                ]
            )
        )
        while os.path.exists(f"files/pdb/{_final_name}_v{self.file_number}.pdb"):
            self.file_number += 1

        self.final_name = f"{_final_name}_v{self.file_number}.pdb"
        with open("packmol.inp", "w") as out:
            out.write("##Automatically generated by LangChain\n")
            out.write("tolerance 2.0\n")
            out.write("filetype pdb\n")
            out.write(
                f"output {self.final_name}\n"
            )  # this is the name of the final file
            out.close()
        return None

    def generate_input(self) -> str:
        input_data = []
        for molecule in self.molecules:
            input_data.append(f"structure {molecule.filename}")
            input_data.append(f"  number {molecule.number_of_molecules}")
            for idx, instruction in enumerate(molecule.instructions):
                input_data.append(f"  {molecule.instructions[idx]}")
            input_data.append("end structure")

        # Convert list of input data to a single string
        return "\n".join(input_data)

    def run_packmol(self):
        # Use the generated input to execute Packmol
        input_string = self.generate_input()
        # Write the input to a file
        with open("packmol.inp", "a") as f:
            f.write(input_string)
        # Here, run Packmol using the subprocess module or similar
        cmd = "packmol < packmol.inp"
        result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
        if result.returncode != 0:
            print("Packmol failed to run with 'packmol < packmol.inp' command")
            result = subprocess.run(
                "./" + cmd, shell=True, text=True, capture_output=True
            )
            if result.returncode != 0:
                raise RuntimeError(
                    "Packmol failed to run with './packmol < packmol.inp' "
                    "command. Please check the input file and try again."
                )

        # validate final pdb
        pdb_validation = validate_pdb_format(f"{self.final_name}")
        if pdb_validation[0] == 0:
            # delete .inp files
            # os.remove("packmol.inp")
            for molecule in self.molecules:
                os.remove(molecule.filename)
            # name of packed pdb file
            time_stamp = self.path_registry.get_timestamp()[-6:]
            os.rename(self.final_name, f"files/pdb/{self.final_name}")
            self.path_registry.map_path(
                f"PACKED_{time_stamp}",
                f"files/pdb/{self.final_name}",
                self.file_description,
            )
            # move file to files/pdb
            print("successfull!")
            return f"PDB file validated successfully. FileID: PACKED_{time_stamp}"
        elif pdb_validation[0] == 1:
            # format pdb_validation[1] list of errors
            errors = summarize_errors(pdb_validation[1])
            # delete .inp files

            # os.remove("packmol.inp")
            print("errors:", f"{errors}")
            return "PDB file not validated, errors found {}".format(("\n").join(errors))


# define function that takes in a list of
#  molecules and a list of instructions and returns a pdb file


def packmol_wrapper(
    path_registry,
    pdbfiles: List,
    files_id: List,
    number_of_molecules: List,
    instructions: List[List],
):
    """Useful when you need to create a box
    of different types of molecules molecules"""

    # create a box
    box = PackmolBox(path_registry)
    # add molecules to the box
    for (
        pdbfile,
        file_id,
        number_of_molecules,
        instructions,
    ) in zip(pdbfiles, files_id, number_of_molecules, instructions):
        molecule = Molecule(pdbfile, file_id, number_of_molecules, instructions)
        box.add_molecule(molecule)
    # generate input header
    box.generate_input_header()
    # generate input
    # run packmol
    print("Packing:", box.file_description, "\nThe file name is:", box.final_name)
    return box.run_packmol()


"""Args schema for packmol_wrapper tool. Useful for OpenAI functions"""
##TODO


class PackmolInput(BaseModel):
    pdbfiles_id: typing.Optional[typing.List[str]] = Field(
        ..., description="List of PDB files id (path_registry) to pack into a box"
    )
    small_molecules: typing.Optional[typing.List[str]] = Field(
        [],
        description=(
            "List of small molecules to be packed in the system. "
            "Examples: water, benzene, toluene, etc."
        ),
    )

    number_of_molecules: typing.Optional[typing.List[int]] = Field(
        ...,
        description=(
            "List of number of instances of each species to pack into the box. "
            "One number per species (either protein or small molecule) "
        ),
    )
    instructions: typing.Optional[typing.List[List[str]]] = Field(
        ...,
        description=(
            "List of instructions for each species. "
            "One List per Molecule. "
            "Every instruction should be one string like:\n"
            "'inside box 0. 0. 0. 90. 90. 90.'"
        ),
    )


class PackMolTool(BaseTool):
    name: str = "packmol_tool"
    description: str = (
        "Useful when you need to create a box "
        "of different types of chemical species.\n"
        "Three different examples:\n"
        "pdbfiles_id: ['1a2b_123456']\n"
        "small_molecules: ['water'] \n"
        "number_of_molecules: [1, 1000]\n"
        "instructions: [['fixed 0. 0. 0. 0. 0. 0. \n centerofmass'], "
        "['inside box 0. 0. 0. 90. 90. 90.']]\n"
        "will pack 1 molecule of 1a2b_123456 at the origin "
        "and 1000 molecules of water. \n"
        "pdbfiles_id: ['1a2b_123456']\n"
        "number_of_molecules: [1]\n"
        "instructions: [['fixed  0. 0. 0. 0. 0. 0.' \n center]]\n"
        "This will fix the barocenter of protein 1a2b_123456 at "
        "the center of the box with no rotation.\n"
        "pdbfiles_id: ['1a2b_123456']\n"
        "number_of_molecules: [1]\n"
        "instructions: [['outside sphere 2.30 3.40 4.50 8.0]]\n"
        "This will place the protein 1a2b_123456 outside a sphere "
        "centered at 2.30 3.40 4.50 with radius 8.0\n"
    )

    args_schema: Type[BaseModel] = PackmolInput

    path_registry: typing.Optional[PathRegistry]

    def __init__(self, path_registry: typing.Optional[PathRegistry]):
        super().__init__()
        self.path_registry = path_registry

    def _get_sm_pdbs(self, small_molecules):
        all_files = self.path_registry.list_path_names()
        for molecule in small_molecules:
            # check path registry for molecule.pdb
            if molecule not in all_files:
                # download molecule using small_molecule_pdb from MolPDB
                molpdb = MolPDB(self.path_registry)
                molpdb.small_molecule_pdb(molecule)
        print("Small molecules PDBs created successfully")

    def _run(self, **values) -> str:
        """use the tool."""

        if self.path_registry is None:  # this should not happen
            raise ValidationError("Path registry not initialized")
        try:
            values = self.validate_input(values)
        except ValidationError as e:
            return str(e)
        error_msg = values.get("error", None)
        if error_msg:
            print("Error in Packmol inputs:", error_msg)
            return f"Error in inputs: {error_msg}"
        print("Starting Packmol Tool!")
        pdbfile_ids = values.get("pdbfiles_id", [])
        pdbfiles = [
            self.path_registry.get_mapped_path(pdbfile) for pdbfile in pdbfile_ids
        ]
        pdbfile_names = [pdbfile.split("/")[-1] for pdbfile in pdbfiles]
        # copy them to the current directory with temp_ names

        pdbfile_names = [f"temp_{pdbfile_name}" for pdbfile_name in pdbfile_names]
        number_of_molecules = values.get("number_of_molecules", [])
        instructions = values.get("instructions", [])
        small_molecules = values.get("small_molecules", [])
        # make sure small molecules are all downloaded
        self._get_sm_pdbs(small_molecules)
        small_molecules_files = [
            self.path_registry.get_mapped_path(sm) for sm in small_molecules
        ]
        small_molecules_file_names = [
            small_molecule.split("/")[-1] for small_molecule in small_molecules_files
        ]
        small_molecules_file_names = [
            f"temp_{small_molecule_file_name}"
            for small_molecule_file_name in small_molecules_file_names
        ]
        # append small molecules to pdbfiles
        pdbfiles.extend(small_molecules_files)
        pdbfile_names.extend(small_molecules_file_names)
        pdbfile_ids.extend(small_molecules)

        for pdbfile, pdbfile_name in zip(pdbfiles, pdbfile_names):
            os.system(f"cp {pdbfile} {pdbfile_name}")
        # check if packmol is installed
        cmd = "command -v packmol"
        result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
        if result.returncode != 0:
            result = subprocess.run(
                "./" + cmd, shell=True, text=True, capture_output=True
            )
            if result.returncode != 0:
                return (
                    "Packmol is not installed. Please install"
                    "packmol at "
                    "'https://m3g.github.io/packmol/download.shtml'"
                    "and try again."
                )
        try:
            return packmol_wrapper(
                self.path_registry,
                pdbfiles=pdbfile_names,
                files_id=pdbfile_ids,
                number_of_molecules=number_of_molecules,
                instructions=instructions,
            )
        except RuntimeError as e:
            return f"Packmol failed to run with error: {e}"

    def validate_input(cls, values: Union[str, Dict[str, Any]]) -> Dict:
        # check if is only a string
        if isinstance(values, str):
            print("values is a string", values)
            raise ValidationError("Input must be a dictionary")
        pdbfiles = values.get("pdbfiles_id", [])
        small_molecules = values.get("small_molecules", [])
        number_of_molecules = values.get("number_of_molecules", [])
        instructions = values.get("instructions", [])
        number_of_species = len(pdbfiles) + len(small_molecules)

        if not number_of_species == len(number_of_molecules):
            if not number_of_species == len(instructions):
                return {
                    "error": (
                        "The length of number_of_molecules AND instructions "
                        "must be equal to the number of species in the system. "
                        f"You have {number_of_species} "
                        f"from {len(pdbfiles)} pdbfiles and {len(small_molecules)} "
                        "small molecules"
                    )
                }
            return {
                "error": (
                    "The length of number_of_molecules must be equal to the "
                    f"number of species in the system. You have {number_of_species} "
                    f"from {len(pdbfiles)} pdbfiles and {len(small_molecules)} "
                    "small molecules"
                )
            }
        elif not number_of_species == len(instructions):
            return {
                "error": (
                    "The length of instructions must be equal to the "
                    f"number of species in the system. You have {number_of_species} "
                    f"from {len(pdbfiles)} pdbfiles and {len(small_molecules)} "
                    "small molecules"
                )
            }
        registry = PathRegistry.get_instance()
        molPDB = MolPDB(registry)
        for instruction in instructions:
            if len(instruction) != 1:
                return {
                    "error": (
                        "Each instruction must be a single string. "
                        "If necessary, use newlines in a instruction string."
                    )
                }
            # TODO enhance this validation with more packmol instructions
            first_word = instruction[0].split(" ")[0]
            if first_word == "center":
                if len(instruction[0].split(" ")) == 1:
                    return {
                        "error": (
                            "The instruction 'center' must be accompanied by more "
                            "instructions. Example 'fixed 0. 0. 0. 0. 0. 0.' "
                            "The complete instruction would be: 'center \n fixed 0. 0. "
                            "0. 0. 0. 0.' with a newline separating the two "
                            "instructions."
                        )
                    }
            elif first_word not in [
                "inside",
                "outside",
                "fixed",
            ]:
                return {
                    "error": (
                        "The first word of each instruction must be one of "
                        "'inside' or 'outside' or 'fixed' \n"
                        "examples: center \n fixed 0. 0. 0. 0. 0. 0.,\n"
                        "inside box -10. 0. 0. 10. 10. 10. \n"
                    )
                }

        # Further validation, e.g., checking if files exist
        file_ids = registry.list_path_names()

        for pdbfile_id in pdbfiles:
            if "_" not in pdbfile_id:
                return {
                    "error": (
                        f"{pdbfile_id} is not a valid pdbfile_id in the path_registry"
                    )
                }
            if pdbfile_id not in file_ids:
                # look for files in the current directory
                # that match some part of the pdbfile
                ids_w_description = registry.list_path_names_and_descriptions()

                return {
                    "error": (
                        f"PDB file ID {pdbfile_id} does not exist "
                        "in the path registry.\n"
                        f"This are the files IDs: {ids_w_description} "
                    )
                }
            for small_molecule in small_molecules:
                if small_molecule not in file_ids:
                    result = molPDB.small_molecule_pdb(small_molecule)
                    if "successfully" not in result:
                        return {
                            "error": (
                                f"{small_molecule} could not be converted to a pdb "
                                "file. Try with a different name, or with the SMILES "
                                "of the small molecule"
                            )
                        }
        return values

    async def _arun(self, values: str) -> str:
        """Use the tool asynchronously."""
        raise NotImplementedError("custom_search does not support async")


########VALIDATION AND FIXING PDB FILES########################


class PDBsummarizerfxns:
    def __init__(self):
        self.list_of_elements = list_of_elements

    def _record_inf(self, pdbfile):
        with open(pdbfile, "r") as f:
            lines = f.readlines()
            remarks = [
                record_lines
                for record_lines in lines
                if record_lines.startswith("REMARK")
            ]
            atoms = [
                record_lines
                for record_lines in lines
                if record_lines.startswith("ATOM")
            ]
            box = [
                record_lines
                for record_lines in lines
                if record_lines.startswith("CRYST1")
            ]
            HETATM = [
                record_lines
                for record_lines in lines
                if record_lines.startswith("HETATM")
            ]

        return remarks, atoms, box, HETATM

    def _num_of_dif_residues(self, pdbfile):
        remarks, atoms, box, HETATM = self._record_inf(pdbfile)
        residues = [atom[17:20] for atom in atoms]
        residues = list(set(residues))
        return len(residues)

    # diagnosis
    """Checks for the elements names in the pdb file.
    Positions 76-78 of the ATOM and HETATM records"""

    def _atoms_have_elements(self, pdbfile):
        _, atoms, _, _ = self._record_inf(pdbfile)
        print(atoms)
        elements = [atom[76:78] for atom in atoms if atom not in [" ", "", "  ", "   "]]
        print(elements)
        if len(elements) != len(atoms):
            print(
                (
                    "No elements in the ATOM records there are"
                    "{len(elements)} elements and {len(atoms)}"
                    "atoms records"
                )
            )
            return False
        elements = list(set(elements))
        for element in elements:
            if element not in self.list_of_elements:
                print("Element not in the list of elements")
                return False
        return True

    def _atoms_have_tempFactor(self, pdbfile):
        _, atoms, _, _ = self._record_inf(pdbfile)
        tempFactor = [
            atom[60:66]
            for atom in atoms
            if atom[60:66] not in [" ", "", "  ", "   ", "  ", "      "]
        ]
        if len(tempFactor) != len(atoms):
            return False
        return True

    def _atoms_have_occupancy(self, pdbfile):
        _, atoms, _, _ = self._record_inf(pdbfile)
        occupancy = [
            atom[54:60]
            for atom in atoms
            if atom[54:60] not in [" ", "", "  ", "   ", "  ", "      "]
        ]
        if len(occupancy) != len(atoms):
            return False
        return True

    def _hetatom_have_occupancy(self, pdbfile):
        _, _, _, HETATM = self._record_inf(pdbfile)
        occupancy = [
            atom[54:60]
            for atom in HETATM
            if atom[54:60] not in [" ", "", "  ", "   ", "  ", "      "]
        ]
        if len(occupancy) != len(HETATM):
            return False
        return True

    def _hetatm_have_elements(self, pdbfile):
        _, _, _, HETATM = self._record_inf(pdbfile)
        elements = [
            atom[76:78] for atom in HETATM if atom[76:78] not in [" ", "", "  ", "   "]
        ]
        if len(elements) != len(HETATM):
            print("No elements in the HETATM records")
            return False
        return True

    def _hetatm_have_tempFactor(self, pdbfile):
        _, _, _, HETATM = self._record_inf(pdbfile)
        tempFactor = [
            atom[60:66] for atom in HETATM if atom not in [" ", "", "  ", "   "]
        ]
        if len(tempFactor) != len(HETATM):
            return False
        return True

    """Checks for the residue names in the pdb file.
      Positions 17-20 of the ATOM and HETATM records"""

    def _atoms_hetatm_have_residue_names(self, pdbfile):
        _, atoms, _, HETATM = self._record_inf(pdbfile)
        residues = [atom[17:20] for atom in atoms]
        residues = list(set(residues))
        if len(residues) != len(atoms):
            return False
        residues = [atom[17:20] for atom in HETATM]
        residues = list(set(residues))
        if len(residues) != len(HETATM):
            return False
        return True

    def _atoms_hetatm_have_occupancy(self, pdbfile):
        _, atoms, _, HETATM = self._record_inf(pdbfile)
        occupancy = [
            atom[54:60]
            for atom in atoms
            if atom not in [" ", "", "  ", "   ", "  ", "      "]
        ]
        if len(occupancy) != len(atoms):
            return False
        occupancy = [
            HET[54:60]
            for HET in HETATM
            if HET not in [" ", "", "  ", "   ", "  ", "      "]
        ]
        if len(occupancy) != len(HETATM):
            return False
        return True

    def _non_standard_residues(self, pdbfile):
        fixer = PDBFixer(file_name=pdbfile)
        fixer.findNonstandardResidues()
        len(fixer.nonstandardResidues)


def pdb_summarizer(pdb_file):
    pdb = PDBsummarizerfxns()
    pdb.remarks, pdb.atoms, pdb.box, pdb.HETATM = pdb._record_inf(pdb_file)
    pdb.atoms_elems = pdb._atoms_have_elements(pdb_file)
    pdb.HETATM_elems = pdb._hetatm_have_elements(pdb_file)
    pdb.residues = pdb._atoms_hetatm_have_residue_names(pdb_file)
    pdb.atoms_tempFact = pdb._atoms_have_tempFactor(pdb_file)
    pdb.num_of_residues = pdb._num_of_dif_residues(pdb_file)
    pdb.HETATM_tempFact = pdb._hetatm_have_tempFactor(pdb_file)

    output = (
        f"PDB file: {pdb_file} has the following properties:"
        "Number of residues: {pdb.num_of_residues}"
        "Are elements identifiers present: {pdb.atoms}"
        "Are HETATM elements identifiers present: {pdb.HETATM}"
        "Are residue names present: {pdb.residues}"
        "Are box dimensions present: {pdb.box}"
        "Non-standard residues: {pdb.HETATM}"
    )
    return output


def _fix_element_column(pdb_file, custom_element_dict=None):
    records = ("ATOM", "HETATM", "ANISOU")
    corrected_lines = []
    for line in pdb_file:
        if line.startswith(records):
            atom_name = line[12:16]

            if atom_name[0].isalpha() and not atom_name[2:].isdigit():
                element = atom_name.strip()
            else:
                atom_name = atom_name.strip()
                if atom_name[0].isdigit():
                    element = atom_name[1]
                else:
                    element = atom_name[0]

            if element not in set(list_of_elements):
                element = "  "  # empty element in case we cannot assign

            line = line[:76] + element.rjust(2) + line[78:]
            corrected_lines.append(line)

    return corrected_lines


def fix_element_column(pdb_file, custom_element_dict=None):
    """Fixes the Element columns of a pdb file"""

    # extract Title, Header, Remarks, and Cryst1 records
    file_name = pdb_file.split(".")[0]
    # check if theres a file-name-fixed.pdb file
    if os.path.isfile(file_name + "-fixed.pdb"):
        pdb_file = file_name + "-fixed.pdb"
    assert isinstance(pdb_file, str), "pdb_file must be a string"
    with open(pdb_file, "r") as f:
        print("I read the initial file")
        pdb_file_lines = f.readlines()
        # validate if pdbfile has element records
        pdb = PDBsummarizerfxns()
        atoms_have_elems, HETATM_have_elems = pdb._atoms_have_elements(
            pdb_file
        ), pdb._hetatm_have_elements(pdb_file)
        if atoms_have_elems and HETATM_have_elems:
            f.close()
            return (
                "Element's column already filled with"
                "elements, no fix needed for elements"
            )
        print("I closed the initial file")
        f.close()

    # fix element column
    records = ("TITLE", "HEADER", "REMARK", "CRYST1", "HET", "LINK", "SEQRES")
    final_records = ("CONECT", "MASTER", "END")
    _unchanged_records = []
    _unchanged_final_records = []
    print("pdb_file", pdb_file)
    for line in pdb_file_lines:
        if line.startswith(records):
            _unchanged_records.append(line)
        elif line.startswith(final_records):
            _unchanged_final_records.append(line)
    print("_unchanged_records", _unchanged_records)
    new_pdb = _fix_element_column(pdb_file_lines, custom_element_dict)
    # join the linees
    new_pdb = "".join(new_pdb)
    # write new pdb file as pdb_file-fixed.pdb
    new_pdb_file = file_name.split(".")[0] + "-fixed.pdb"
    print("name of fixed pdb file", new_pdb_file)
    # write the unchanged records first and then the new pdb file
    assert isinstance(new_pdb_file, str), "new_pdb_file must be a string"
    with open(new_pdb_file, "w") as f:
        print("I wrote the new file")
        f.writelines(_unchanged_records)
        f.write(new_pdb)
        f.writelines(_unchanged_final_records)
        f.close()
    try:
        # read the new pdb file and check if it has element records
        with open(new_pdb_file, "r") as f:
            pdb_file_lines = f.readlines()
            pdb = PDBsummarizerfxns()
            atoms_have_elems, HETATM_have_elems = pdb._atoms_have_elements(
                new_pdb_file
            ), pdb._hetatm_have_elements(new_pdb_file)
            if atoms_have_elems and HETATM_have_elems:
                f.close()
                return "Element's column fixed successfully"
            else:
                f.close()
                return "Element's column not fixed, and i dont know why"
    except Exception as e:
        return f"Element's column not fixed error: {e}"


class FixElementColumnArgs(BaseTool):
    # arguments of fix_element_column
    pdb_file: str = Field(..., description="PDB file to be fixed")
    custom_element_dict: dict = Field(
        None,
        description=(
            "Custom element dictionary. If None," "the default dictionary is used"
        ),
    )


def pad_line(line):
    """Pad line to 80 characters in case it is shorter."""
    size_of_line = len(line)
    if size_of_line < 80:
        padding = 80 - size_of_line + 1
        line = line.strip("\n") + " " * padding + "\n"
    return line[:81]  # 80 + newline character


def _fix_temp_factor_column(pdbfile, bfactor, only_fill):
    """Set the temperature column in all ATOM/HETATM records to a given value.

    This function is a generator.

    Parameters
    ----------
    fhandle : a line-by-line iterator of the original PDB file.

    bfactor : float
        The desired bfactor.

    Yields
    ------
    str (line-by-line)
        The modified (or not) PDB line."""
    _pad_line = pad_line
    records = ("ATOM", "HETATM")
    corrected_lines = []
    bfactor = "{0:>6.2f}".format(bfactor)

    for line in pdbfile:
        if line.startswith(records):
            line = _pad_line(line)
            if only_fill:
                if line[60:66].strip() == "":
                    corrected_lines.append(line[:60] + bfactor + line[66:])
            else:
                corrected_lines.append(line[:60] + bfactor + line[66:])
        else:
            corrected_lines.append(line)

    return corrected_lines


def fix_temp_factor_column(pdb_file, bfactor=1.00, only_fill=True):
    """Fixes the tempFactor columns of a pdb file"""

    # extract Title, Header, Remarks, and Cryst1 records
    # get name from pdb_file
    if isinstance(pdb_file, str):
        file_name = pdb_file.split(".")[0]
    else:
        return "pdb_file must be a string"
    file_name = pdb_file.split(".")[0]

    if os.path.isfile(file_name + "-fixed.pdb"):
        file_name = file_name + "-fixed.pdb"

    assert isinstance(file_name, str), "pdb_file must be a string"
    with open(file_name, "r") as f:
        print("im reading the files temp factor")
        pdb_file_lines = f.readlines()
        # validate if pdbfile has temp factors
        pdb = PDBsummarizerfxns()
        atoms_have_bfactor, HETATM_have_bfactor = pdb._atoms_have_tempFactor(
            pdb_file
        ), pdb._hetatm_have_tempFactor(pdb_file)
        if atoms_have_bfactor and HETATM_have_bfactor and only_fill:
            # print("Im closing the file temp factor")
            f.close()
            return (
                "TempFact column filled with bfactor already,"
                "no fix needed for temp factor"
            )
        f.close()
    # fix element column
    records = ("TITLE", "HEADER", "REMARK", "CRYST1", "HET", "LINK", "SEQRES")
    final_records = ("CONECT", "MASTER", "END")
    _unchanged_final_records = []
    _unchanged_records = []
    for line in pdb_file_lines:
        if line.startswith(records):
            _unchanged_records.append(line)
        elif line.startswith(final_records):
            _unchanged_final_records.append(line)

    new_pdb = _fix_temp_factor_column(pdb_file_lines, bfactor, only_fill)
    # join the linees
    new_pdb = "".join(new_pdb)
    # write new pdb file as pdb_file-fixed.pdb
    new_pdb_file = file_name + "-fixed.pdb"
    # organize columns HEADER, TITLE, REMARKS, CRYST1, ATOM, HETATM, CONECT, MASTER, END

    assert isinstance(new_pdb_file, str), "new_pdb_file must be a string"
    # write new pdb file as pdb_file-fixed.pdb
    with open(new_pdb_file, "w") as f:
        f.writelines(_unchanged_records)
        f.write(new_pdb)
        f.writelines(_unchanged_final_records)
        f.close()
    try:
        # read the new pdb file and check if it has element records
        with open(new_pdb_file, "r") as f:
            pdb_file = f.readlines()
            pdb = PDBsummarizerfxns()
            atoms_have_bfactor, HETATM_have_bfactor = pdb._atoms_have_tempFactor(
                new_pdb_file
            ), pdb._hetatm_have_tempFactor(new_pdb_file)
            if atoms_have_bfactor and HETATM_have_bfactor:
                f.close()
                return "TempFact fixed successfully"
            else:
                f.close()
                return "TempFact column not fixed"
    except Exception as e:
        return f"Couldnt read written file TempFact column not fixed error: {e}"


class FixTempFactorColumnArgs(BaseTool):
    # arguments of fix_element_column
    pdb_file: str = Field(..., description="PDB file to be fixed")
    bfactor: float = Field(1.0, description="Bfactor value to use")
    only_fill: bool = Field(
        True,
        description=(
            "Only fill empty bfactor columns."
            "Avoids replacing existing values."
            "False if you want to replace all values"
            "with the bfactor value"
        ),
    )


def _fix_occupancy_column(pdbfile, occupancy, only_fill):
    """
    Set the occupancy column in all ATOM/HETATM records to a given value.

    Non-ATOM/HETATM lines are give as are. This function is a generator.

    Parameters
    ----------
    fhandle : a line-by-line iterator of the original PDB file.

    occupancy : float
        The desired occupancy value

    Yields
    ------
    str (line-by-line)
        The modified (or not) PDB line.
    """

    records = ("ATOM", "HETATM")
    corrected_lines = []
    occupancy = "{0:>6.2f}".format(occupancy)
    for line in pdbfile:
        if line.startswith(records):
            line = pad_line(line)
            if only_fill:
                if line[54:60].strip() == "":
                    corrected_lines.append(line[:54] + occupancy + line[60:])
            else:
                corrected_lines.append(line[:54] + occupancy + line[60:])
        else:
            corrected_lines.append(line)

    return corrected_lines


def fix_occupancy_columns(pdb_file, occupancy=1.0, only_fill=True):
    """Fixes the occupancy columns of a pdb file"""
    # extract Title, Header, Remarks, and Cryst1 records
    # get name from pdb_file
    file_name = pdb_file.split(".")[0]
    if os.path.isfile(file_name + "-fixed.pdb"):
        file_name = file_name + "-fixed.pdb"

    assert isinstance(pdb_file, str), "pdb_file must be a string"
    with open(file_name, "r") as f:
        pdb_file_lines = f.readlines()
        # validate if pdbfile has occupancy
        pdb = PDBsummarizerfxns()
        atoms_have_bfactor, HETATM_have_bfactor = pdb._atoms_have_occupancy(
            file_name
        ), pdb._hetatom_have_occupancy(file_name)
        if atoms_have_bfactor and HETATM_have_bfactor and only_fill:
            f.close()
            return (
                "Occupancy column filled with occupancy"
                "already, no fix needed for occupancy"
            )
        f.close()
    # fix element column
    records = ("TITLE", "HEADER", "REMARK", "CRYST1", "HET", "LINK", "SEQRES")
    final_records = ("CONECT", "MASTER", "END")
    _unchanged_records = []
    _unchanged_final_records = []
    for line in pdb_file_lines:
        if line.startswith(records):
            _unchanged_records.append(line)
        elif line.startswith(final_records):
            _unchanged_final_records.append(line)

    new_pdb = _fix_occupancy_column(pdb_file_lines, occupancy, only_fill)
    # join the linees
    new_pdb = "".join(new_pdb)
    # write new pdb file as pdb_file-fixed.pdb
    new_pdb_file = file_name + "-fixed.pdb"

    # write new pdb file as pdb_file-fixed.pdb
    assert isinstance(new_pdb_file, str), "new_pdb_file must be a string"
    with open(new_pdb_file, "w") as f:
        f.writelines(_unchanged_records)
        f.write(new_pdb)
        f.writelines(_unchanged_final_records)
        f.close()
    try:
        # read the new pdb file and check if it has element records
        with open(new_pdb_file, "r") as f:
            pdb_file = f.readlines()
            pdb = PDBsummarizerfxns()
            atoms_have_bfactor, HETATM_have_bfactor = pdb._atoms_have_tempFactor(
                new_pdb_file
            ), pdb._hetatm_have_tempFactor(new_pdb_file)
            if atoms_have_bfactor and HETATM_have_bfactor:
                f.close()
                return "Occupancy fixed successfully"
            else:
                f.close()
                return "Occupancy column not fixed"
    except Exception:
        return "Couldnt read file Occupancy's column not fixed"


class FixOccupancyColumnArgs(BaseTool):
    # arguments of fix_element_column
    pdb_file: str = Field(..., description="PDB file to be fixed")
    occupancy: float = Field(1.0, description="Occupancy value to be set")
    only_fill: bool = Field(
        True,
        description=(
            "Only fill empty occupancy columns."
            "Avoids replacing existing values."
            "False if you want to replace all"
            "values with the occupancy value"
        ),
    )


# Define a mapping between query keys and functions.
# If a function requires additional arguments from the query, define it as a lambda.
FUNCTION_MAP = {
    "ElemColum": lambda pdbfile, params: fix_element_column(pdbfile),
    "tempFactor": lambda pdbfile, params: fix_temp_factor_column(pdbfile, *params),
    "Occupancy": lambda pdbfile, params: fix_occupancy_columns(pdbfile, *params),
}


def apply_fixes(pdbfile, query):
    # Iterate through the keys and functions in FUNCTION_MAP.
    for key, func in FUNCTION_MAP.items():
        # Check if the current key is in the query and is not None.
        params = query.get(key)
        if params is not None:
            # If it is, call the function with
            # pdbfile and the parameters from the query.
            func(pdbfile, params)

            return "PDB file fixed"


class PDBFilesFixInp(BaseModel):
    pdbfile: str = Field(..., description="PDB file to be fixed")
    ElemColum: typing.Optional[bool] = Field(
        False,
        description=(
            "List of fixes to be applied. If None, a"
            "validation of what fixes are needed is performed."
        ),
    )
    tempFactor: typing.Optional[typing.Tuple[float, bool]] = Field(
        (...),
        description=(
            "Tuple of     ( float, bool)"
            "first arg is the"
            "value to be set as the tempFill, and third arg indicates"
            "if only empty TempFactor columns have to be filled"
        ),
    )
    Occupancy: typing.Optional[typing.Tuple[float, bool]] = Field(
        (...),
        description=(
            "Tuple of (bool, float, bool)"
            "where first arg indicates if Occupancy"
            "fix has to be applied, second arg is the"
            "value to be set, and third arg indicates"
            "if only empty Occupancy columns have to be filled"
        ),
    )

    @root_validator
    def validate_input(cls, values: Union[str, Dict[str, Any]]) -> Dict:
        if isinstance(values, str):
            print("values is a string", values)
            raise ValidationError("Input must be a dictionary")

        pdbfile = values.get("pdbfiles", "")
        occupancy = values.get("occupancy")
        tempFactor = values.get("tempFactor")
        ElemColum = values.get("ElemColum")

        if occupancy is None and tempFactor is None and ElemColum is None:
            if pdbfile == "":
                return {"error": "No inputs given, failed use of tool."}
            else:
                return values
        else:
            if occupancy:
                if len(occupancy) != 2:
                    return {
                        "error": (
                            "if you want to fix the occupancy"
                            "column argument must be a tuple of (bool, float)"
                        )
                    }
                if not isinstance(occupancy[0], float):
                    return {"error": "occupancy first arg must be a float"}
                if not isinstance(occupancy[1], bool):
                    return {"error": "occupancy second arg must be a bool"}
            if tempFactor:
                if len(tempFactor != 2):
                    return {
                        "error": (
                            "if you want to fix the tempFactor"
                            "column argument must be a tuple of (float, bool)"
                        )
                    }
                if not isinstance(tempFactor[0], bool):
                    return {"error": "occupancy first arg must be a float"}
                if not isinstance(tempFactor[1], float):
                    return {"error": "tempFactor second arg must be a float"}
            if ElemColum is not None:
                if not isinstance(ElemColum[1], bool):
                    return {"error": "ElemColum must be a bool"}
            return values


class FixPDBFile(BaseTool):
    name: str = "PDBFileFixer"
    description: str = "Fixes PDB files columns if needed"
    args_schema: Type[BaseModel] = PDBFilesFixInp

    path_registry: Optional[PathRegistry]

    def __init__(self, path_registry: Optional[PathRegistry]):
        super().__init__()
        self.path_registry = path_registry

    def _run(self, query: Dict):
        """use the tool."""
        if self.path_registry is None:
            raise ValidationError("Path registry not initialized")
        error_msg = query.get("error")
        if error_msg:
            return error_msg
        pdbfile = query.pop("pdbfile")
        if len(query.keys()) == 0:
            validation = validate_pdb_format(pdbfile)
            if validation[0] == 0:
                return "PDB file is valid, no need to fix it"

            if validation[0] == 1:
                # Convert summarized_errors into a set for O(1) lookups
                error_set = set(validation[1])

                # Apply Fixes
                if "At. Elem." in error_set:
                    fix_element_column(pdbfile)
                if "Tmp. Fac." in error_set:
                    fix_temp_factor_column(pdbfile)
                if "Occupancy" in error_set:
                    fix_occupancy_columns(pdbfile)

                validate = validate_pdb_format(pdbfile + "-fixed.pdb")
                if validate[0] == 0:
                    name = pdbfile + "-fixed.pdb"
                    description = "PDB file fixed"
                    self.path_registry.map_path(name, name, description)
                    return "PDB file fixed"
                else:
                    return "PDB not fully fixed"
        else:
            apply_fixes(pdbfile, query)
            validate = validate_pdb_format(pdbfile + "-fixed.pdb")
            if validate[0] == 0:
                name = pdbfile + "-fixed.pdb"
                description = "PDB file fixed"
                self.path_registry.map_path(name, name, description)
                return "PDB file fixed"
            else:
                return "PDB not fully fixed"
